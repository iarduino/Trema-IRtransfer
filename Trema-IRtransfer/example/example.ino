#include <IRtransfer.h>
IRtransfer	IR;

/*  
Библиотека IRtransfer предназначена для работы arduino с ИК приёмопередатчиками
http://iarduino.ru/shop/Sensory-Datchiki/ik-priemnik-trema-modul.html

В библиотеке реализованы 4 функции:
Функция begin     Назначение:            Инициализация ИК датчика и при необходимости светодиода
                  Синтаксис:             begin( uint8_t №_вывода_ИК_датчика [, uint8_t №_вывода_ИК_светодиода [, bool флаг_инверсии_сигнала_для_ИК_светодиода ]]);
                  Возвращаемые значения: Нет
                  Примечание:            Вызывается 1 раз в начале кода. Сама определяет нужна или нет инверсия сигнала от ИК датчика
                                         Если нет необходимость передавать сигналы, то 2 и 3 параметры можно не указывать
                                         Флаг инверсии сигнала для ИК светодиода по умолчанию равен false - без инверсии, то есть при отсутствии сигнала, на выводе для ИК светодиода устанавливается логический 0

Функция check     Назначение:            Определение и расшифровка принятых данных
                  Синтаксис:             check([ bool флаг_реагирования_на_сигналы_удержания_кнопки_пульта]);
                  Возвращаемые значения: bool true - при наличии принятого сигнала, или false при его отсутствии
                  Примечание:            После возврата true, данные можно прочитать из переменных - data, length, coding, frequency, data_repeat и length_repeat
                                         Флаг реагирования на сигналы удержания кнопки пульта по умолчанию равен false - не реагировать, то есть при удержании кнопки на пульте, функция вернет true только 1 раз, в момент нажатия
                                         Если указать параметр true, то функция будет возвращать true пока удерживается кнопка на пульте

Функция send      Назначение:            Отправка данных на ИК светодиод (если его вывод указан в функции begin)
                  Синтаксис:             send( uint32_t данные [, bool флаг_отправки_повторов]);
                  Возвращаемые значения: Нет
                  Примечание:            Флаг отправки повторов по умолчанию равен false - отправить только один информационный пакет
                                         Если указать флаг отправки повторов равный true, то функция подавляет дребезг при нажатии кнопки и отправляет пакеты повторов при её удержании
                                         Если не указан протокол передачи данных, от отправка происходит по последнему определённому функцией check протоколу передачи данных

Функция protocol  Назначение:            Указание или чтение строки протокола передачи данных (25 символов + символ конца строки)
                  Синтаксис:             protocol( char* "строка" ); // указание протокола
                  Возвращаемые значения: Нет
                  Синтаксис:             protocol();                 // чтение протокола
                  Возвращаемые значения: char* "строка"
                  Примечание:            При указании параметра - указывается протокол, при отсутствии параметра - возвращается протокол
                                         Возвращаемый протокол передачи данных соответствует протоколу передачи последних успешно принятых функцией check данных
                                         Если указать параметр (в виде строки из 25 символов), то дальнейшие действия приём/передача будут определяться указанным в этой строке протоколом передачи данных
                  
Информация строке протокола и переменных data, length, coding, frequency, data_repeat и length_repeat описана в конце примера.
*/


//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА (ОДИН РАЗ ПРИ КАЖДОМ НАЖАТИИ КНОПКИ ПУЛЬТА)
void setup() {
	Serial.begin(9600);
	IR.begin(4);					// ИК датчик подключён к 4 выводу arduino
}

void loop(){
	if(IR.check()){					// если принят сигнал
		Serial.println(IR.data,HEX);		// вывести данные на монитор
		Serial.println(IR.length);		// вывести размер данных на монитор (количество бит)
		Serial.println(IR.protocol());		// вывести строку с определённым протоколом передачи данных на монитор (25 символов)
	}
}


/*
//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА (ПОСТОЯННО, ПОКА УДЕРЖИВАЕТСЯ КНОПКА НА ПУЛЬТЕ) т.к. вызываем функцию check с параметром true
void setup() {
	Serial.begin(9600);
	IR.begin(4);					// ИК датчик подключён к 4 выводу arduino
}

void loop(){
	if(IR.check(true)){				// если принят сигнал или пакеты повтора
		Serial.println(IR.data,HEX);		// вывести данные на монитор
		Serial.println(IR.length);		// вывести размер данных на монитор (количество бит)
		Serial.println(IR.protocol());		// вывести строку с определённым протоколом передачи данных на монитор (25 символов)
	}
}
*/

/*
//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ПУЛЬТА ELENBERG (ИЛИ ЕМУ ПОДОБНЫХ) т.к. сами указываем протокол передачи данных функцией protocol
void setup() {
	Serial.begin(9600);
	IR.begin(4);					// ИК датчик подключён к 4 выводу arduino
	IR.protocol("AeQQV~zK]Kp^KJp[@@@@@@@Bp");	// указываем протокол передачи данных от пульта ELENBERG (25 символов)
}

void loop(){
	if(IR.check()){					// если принят сигнал с пультов использующих указанный протокол передачи данных
		Serial.println(IR.data,HEX);		// вывести данные о сигнале на монитор
	}						// функция check выполнит чтение данных быстрее чем в предыдущих примерах, т.к. ей уже не нужно определять протокол
}
*/

/*
//	==============================================================================================
//	ПЕРЕДАЁМ ДАННЫЕ НА ТЕЛЕВИЗОР ELENBERG (ИЛИ ЕМУ ПОДОБНЫЙ)
void setup() {
	IR.begin(4,5);					// ИК датчик подключён к 4 выводу arduino, ИК светодиод подключён анодом к 5 выводу, а катодом к GND
	pinMode(6, INPUT);				// 6 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(7, INPUT);				// 7 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(8, INPUT);				// 8 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	IR.protocol("AeQQV~zK]Kp^KJp[@@@@@@@Bp");	// указываем протокол передачи данных от пульта ELENBERG (25 символов)
}

void loop(){
	if(digitalRead(6)){				// если кнопка нажата
		IR.send(0x417,true);			// отправляем сигнал ON/OFF (функция send вызвана с вторым параметром true следовательно она сама подавит дребезг кнопки)
	}
	if(digitalRead(7)){				// если кнопка нажата
		IR.send(0x425,true);			// отправляем сигнал VOL-
	}
	if(digitalRead(8)){				// если кнопка нажата
		IR.send(0x427);				// отправляем сигнал VOL+   (функция send вызвана без второго параметра следовательно команда будет отправляться при каждом цикле loop пока нажата кнопка)
	}						//                          (т.к. это команда VOL+, то громкость увеличится быстрее, чем при использовании второго параметра true.)
}
*/

/*
//	==============================================================================================
//	ПЕРЕДАЁМ ДАННЫЕ НА ТЕЛЕВИЗОР VESTEL (ИЛИ ЕМУ ПОДОБНЫЙ) И ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА
void setup() {
	Serial.begin(9600);
	IR.begin(3,7,true);				// ИК датчик подключён к 3 выводу arduino, ИК светодиод подключён катодом к 7 выводу, а анодом к Vcc
	pinMode(4, INPUT);				// 4 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(5, INPUT);				// 5 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(6, INPUT);				// 6 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
}

void loop(){
	IR.protocol("KdMM[TOcbdb@dQbP@@@@@D@B@");	// указываем протокол передачи данных от пульта VESTEL (25 символов)
	if(digitalRead(4)){				// если кнопка нажата
		IR.send(0x184C,true);			// отправляем сигнал ON/OFF
	}
	if(digitalRead(5)){				// если кнопка нажата
		IR.send(0x1851,true);			// отправляем сигнал VOL-
	}
	if(digitalRead(6)){				// если кнопка нажата
		IR.send(0x1850,true);			// отправляем сигнал VOL+
	}
	IR.coding=0;					// отменяем ранее указанный протокол передачи данных
	if(IR.check()){					// если принят сигнал с любого пульта
		Serial.println(IR.data,HEX);		// вывести данные на монитор
	}
}
*/


/*
//                ==============================================================================================
Переменные:      Указанные переменные доступны для чтения после возврата true функцией check
                 Если изменить значения переменных и вызвать функцию protocol без параметра, то она вернёт строку протокола с учётом изменённых данных
coding           - кодировка                    (целое число от 0 до 63)
                   значение переменной можно сравнивать с константами:
                   coding==IR_UNDEFINED         тип кодирования не определён
                   coding==IR_PAUSE_LENGTH      кодирование длинной паузы
                   coding==IR_PULSE_LENGTH      кодирование шириной импульса (ШИМ)
                   coding==IR_ONE_PULSE_LENGTH  кодирование шириной одного импульса
                   coding==IR_BIPHASIC          бифазное кодирование
                   coding==IR_BIPHASIC_INV      бифазное кодирование с инверсными битами
                   coding==IR_NRC               NOKIA	бифазное кодирование с сигналом старт, пакеты повтора идентичны, первый и последний пакеты специальные
                   coding==IR_RS5               PHILIPS	бифазное кодирование с битом toggle (третий бит в пакете), пакеты повтора идентичны первому
                   coding==IR_RS5X              PHILIPS	бифазное кодирование с битом toggle (второй бит в пакете), пакеты повтора идентичны первому
                   coding==IR_RS6               PHILIPS	бифазное кодирование с битом toggle (пятый бит в пакете) и сигналом старт, пакеты повтора идентичны первому
                   если указать протокол передачи данных функцией protocol, а потом обнулить переменную coding, то указанный протокол будет отменён
frequency        - несущая частота в кГц        (целое число от 0 до 63)
                   данной переменной можно присвоить свою частоту передачи данных, это может увеличить радиус действия при передаче команд функцией send
                   если указать частоту 0 кГц, то функция send будет отправлять не модулированный сигнал
data             - принятые данные              (целое 32 битное число)  только для чтения
length           - количество принятых бит      (целое число от 0 до 32) только для чтения, позволяет отличить данные 0x00FF от данных 0xFF
data_repeat      - принятые данные из пакета повтора (целое 32 битное число) только для чтения
length_repeat    - количество принятых бит из пакета повтора (целое число от 0 до 32) только для чтения, позволяет отличить данные 0x00FF от данных 0xFF

Примечание:      Библиотека использует второй аппаратный таймер, не выводите сигналы ШИМ на 3 или 11 вывод.
                 Строка протокола передачи данных это 25 символов, каждый символ занимает 1 байт.
                   для того чтобы не завесить от кодировок и иметь возможность скопировать строку в скетч с монитора, я "пожертвовал" двумя первыми битами каждого символа, они всегда равны "01"
                   таким образом строка может состоять только из символов латинского алфавита и символов @[]{}\|^`_~
                   оставшиеся 6 бит каждого символа являются информационными и несут информацию о протоколе передачи данных:
                   - символы: 1=coding, 2=frequency, 3=length, 4=length_repeat, 12=позиции_бита_рестарт, 13=макс_длит_импульсов_(мкс/50), 14=мин_длит_импульсов_(мкс/50), 15=макс_длит_пауз_(мкс/50), 16=мин_длит_пауз_(мкс/50).                                                Старшие два бита равные "01" у этих символов заменяются на "00".
                   - символы: 5=длит_пауз_между_пакетами_(мс), 6=длит_импульса_старт_(мкс/50), 7=длит_паузы_старт_(мкс/50), 8=длит_импульса_стоп_(мкс/50), 9=длит_паузы_стоп_(мкс/50), 10=длит_импульса_рестарт_или_toggle_(мкс/50), 11=длит_паузы_рестарт_или_toggle_(мкс/50). Старшие два бита равные "01" у этих символов заменяются на два бита из символов 22,23,24.
                   - символы: 17=старшие_6_бит_пакета_повтора, 18=вторые_6_бит_пакета_повтора, 19=третие_6_бит_пакета_повтора, 20=четвёртые_6_бит_пакета_повтора, 21=пятые_6_бит_пакета_повтора, последние (младшие) 2 бита пакета повтора находятся в 22 символе.              Старшие два бита равные "01" у этих символов не учитываются.
                   - символы: 22,23,24 содержат по три пары бит для предыдущих символов, а символ 25 содержит флаги наличия сигналов старт, рестарт, toggle и стоп.
                 Переменная data (data_repeat) содержит все биты пакета, за исключением сигналов старт, стоп, рестарт и бита toggle.
                 Если сигнал старт (стоп) по своей форме идентичен биту 1 (0), то он расценивается как бит 1 (0) и включается в переменную data (data_repeat)
*/
